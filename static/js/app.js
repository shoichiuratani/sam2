// SAM2 動画追跡 Webアプリ JavaScript

class SAM2WebApp {
    constructor() {
        this.sessionId = null;
        this.currentStep = 1;
        this.selectedPoints = [];
        this.pointMode = 'positive'; // 'positive' or 'negative'
        this.currentFrame = null;
        this.frameCanvas = null;
        this.frameContext = null;
        this.statusCheckInterval = null;
        
        this.init();
    }
    
    init() {
        this.setupEventListeners();
        this.setupCanvas();
    }
    
    setupEventListeners() {
        // ファイル選択
        const fileInput = document.getElementById('video-file');
        const selectFileBtn = document.getElementById('select-file-btn');
        const uploadArea = document.getElementById('upload-area');
        
        selectFileBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => this.handleFileSelect(e.target.files[0]));
        
        // ドラッグ&ドロップ
        uploadArea.addEventListener('dragover', this.handleDragOver.bind(this));
        uploadArea.addEventListener('dragleave', this.handleDragLeave.bind(this));
        uploadArea.addEventListener('drop', this.handleDrop.bind(this));
        
        // フレーム分割
        document.getElementById('extract-frames-btn').addEventListener('click', this.extractFrames.bind(this));
        
        // 座標選択モード
        document.getElementById('add-positive-btn').addEventListener('click', () => this.setPointMode('positive'));
        document.getElementById('add-negative-btn').addEventListener('click', () => this.setPointMode('negative'));
        document.getElementById('clear-points-btn').addEventListener('click', this.clearPoints.bind(this));
        document.getElementById('confirm-points-btn').addEventListener('click', this.confirmPoints.bind(this));
        
        // 追跡開始
        document.getElementById('start-tracking-btn').addEventListener('click', this.startTracking.bind(this));
        
        // 結果ダウンロード
        document.getElementById('download-results-btn').addEventListener('click', this.downloadResults.bind(this));
        document.getElementById('new-session-btn').addEventListener('click', this.newSession.bind(this));
    }
    
    setupCanvas() {
        this.frameCanvas = document.getElementById('frame-canvas');
        this.frameContext = this.frameCanvas.getContext('2d');
        this.frameCanvas.addEventListener('click', this.handleCanvasClick.bind(this));
    }
    
    // ファイル処理
    handleFileSelect(file) {
        if (!file) return;
        this.uploadFile(file);
    }
    
    handleDragOver(e) {
        e.preventDefault();
        document.getElementById('upload-area').classList.add('drag-over');
    }
    
    handleDragLeave(e) {
        e.preventDefault();
        document.getElementById('upload-area').classList.remove('drag-over');
    }
    
    handleDrop(e) {
        e.preventDefault();
        document.getElementById('upload-area').classList.remove('drag-over');
        
        const file = e.dataTransfer.files[0];
        if (file) {
            this.uploadFile(file);
        }
    }
    
    async uploadFile(file) {
        const formData = new FormData();
        formData.append('video', file);
        
        this.showUploadProgress(true);
        
        try {
            const response = await fetch('/upload', {\n                method: 'POST',\n                body: formData\n            });\n            \n            const data = await response.json();\n            \n            if (response.ok) {\n                this.sessionId = data.session_id;\n                this.showMessage(`アップロード完了: ${data.filename}`, 'success');\n                this.nextStep();\n            } else {\n                throw new Error(data.error || 'アップロードに失敗しました');\n            }\n        } catch (error) {\n            this.showMessage(`エラー: ${error.message}`, 'error');\n        } finally {\n            this.showUploadProgress(false);\n        }\n    }\n    \n    async extractFrames() {\n        if (!this.sessionId) {\n            this.showMessage('先に動画をアップロードしてください', 'error');\n            return;\n        }\n        \n        try {\n            const response = await fetch(`/extract_frames/${this.sessionId}`, {\n                method: 'POST'\n            });\n            \n            const data = await response.json();\n            \n            if (response.ok) {\n                this.showMessage(data.message, 'info');\n                this.startStatusCheck();\n            } else {\n                throw new Error(data.error || 'フレーム分割に失敗しました');\n            }\n        } catch (error) {\n            this.showMessage(`エラー: ${error.message}`, 'error');\n        }\n    }\n    \n    async startStatusCheck() {\n        this.statusCheckInterval = setInterval(async () => {\n            try {\n                const response = await fetch(`/status/${this.sessionId}`);\n                const data = await response.json();\n                \n                this.updateProgress(data);\n                \n                if (data.status === 'frames_ready') {\n                    clearInterval(this.statusCheckInterval);\n                    await this.loadFramePreview();\n                    this.nextStep();\n                } else if (data.status === 'completed') {\n                    clearInterval(this.statusCheckInterval);\n                    this.showResults(data.tracking_results);\n                    this.nextStep();\n                } else if (data.status === 'error') {\n                    clearInterval(this.statusCheckInterval);\n                    this.showMessage(`エラー: ${data.error}`, 'error');\n                }\n            } catch (error) {\n                console.error('Status check error:', error);\n            }\n        }, 2000);\n    }\n    \n    async loadFramePreview() {\n        try {\n            const response = await fetch(`/get_frames/${this.sessionId}`);\n            const data = await response.json();\n            \n            if (response.ok) {\n                document.getElementById('total-frames').textContent = data.total_frames;\n                \n                if (data.preview_frames.length > 0) {\n                    await this.loadFrame(data.preview_frames[0].url);\n                }\n            }\n        } catch (error) {\n            this.showMessage(`エラー: ${error.message}`, 'error');\n        }\n    }\n    \n    async loadFrame(frameUrl) {\n        return new Promise((resolve) => {\n            const img = new Image();\n            img.onload = () => {\n                // キャンバスサイズを調整\n                const maxWidth = 800;\n                const maxHeight = 600;\n                const scale = Math.min(maxWidth / img.width, maxHeight / img.height);\n                \n                this.frameCanvas.width = img.width * scale;\n                this.frameCanvas.height = img.height * scale;\n                \n                // 画像を描画\n                this.frameContext.clearRect(0, 0, this.frameCanvas.width, this.frameCanvas.height);\n                this.frameContext.drawImage(img, 0, 0, this.frameCanvas.width, this.frameCanvas.height);\n                \n                this.currentFrame = img;\n                this.redrawPoints();\n                resolve();\n            };\n            img.src = frameUrl;\n        });\n    }\n    \n    // 座標選択\n    setPointMode(mode) {\n        this.pointMode = mode;\n        \n        // ボタンの状態更新\n        document.getElementById('add-positive-btn').classList.toggle('active', mode === 'positive');\n        document.getElementById('add-negative-btn').classList.toggle('active', mode === 'negative');\n        \n        // カーソル変更\n        this.frameCanvas.style.cursor = mode === 'positive' ? 'crosshair' : 'not-allowed';\n    }\n    \n    handleCanvasClick(e) {\n        const rect = this.frameCanvas.getBoundingClientRect();\n        const x = (e.clientX - rect.left) * (this.frameCanvas.width / rect.width);\n        const y = (e.clientY - rect.top) * (this.frameCanvas.height / rect.height);\n        \n        // 座標を追加\n        this.addPoint(x, y, this.pointMode);\n    }\n    \n    addPoint(x, y, type) {\n        const point = {\n            x: Math.round(x),\n            y: Math.round(y),\n            type: type, // 'positive' or 'negative'\n            id: Date.now() // 簡単なID\n        };\n        \n        this.selectedPoints.push(point);\n        this.updatePointsList();\n        this.redrawPoints();\n        \n        // 確定ボタンを有効化\n        document.getElementById('confirm-points-btn').disabled = this.selectedPoints.length === 0;\n    }\n    \n    removePoint(pointId) {\n        this.selectedPoints = this.selectedPoints.filter(p => p.id !== pointId);\n        this.updatePointsList();\n        this.redrawPoints();\n        \n        // 確定ボタンの状態更新\n        document.getElementById('confirm-points-btn').disabled = this.selectedPoints.length === 0;\n    }\n    \n    clearPoints() {\n        this.selectedPoints = [];\n        this.updatePointsList();\n        this.redrawPoints();\n        document.getElementById('confirm-points-btn').disabled = true;\n    }\n    \n    updatePointsList() {\n        const container = document.getElementById('selected-points');\n        \n        if (this.selectedPoints.length === 0) {\n            container.innerHTML = '<p class=\"text-muted\">座標を選択してください</p>';\n            return;\n        }\n        \n        container.innerHTML = this.selectedPoints.map(point => `\n            <div class=\"point-item ${point.type}\">\n                <div class=\"point-coords\">\n                    ${point.type === 'positive' ? '✓' : '✗'} \n                    (${point.x}, ${point.y})\n                </div>\n                <span class=\"point-remove\" onclick=\"app.removePoint(${point.id})\">\n                    <i class=\"fas fa-times\"></i>\n                </span>\n            </div>\n        `).join('');\n    }\n    \n    redrawPoints() {\n        if (!this.currentFrame) return;\n        \n        // フレームを再描画\n        this.frameContext.clearRect(0, 0, this.frameCanvas.width, this.frameCanvas.height);\n        this.frameContext.drawImage(this.currentFrame, 0, 0, this.frameCanvas.width, this.frameCanvas.height);\n        \n        // 座標点を描画\n        this.selectedPoints.forEach(point => {\n            this.frameContext.beginPath();\n            this.frameContext.arc(point.x, point.y, 8, 0, 2 * Math.PI);\n            this.frameContext.fillStyle = point.type === 'positive' ? '#198754' : '#dc3545';\n            this.frameContext.fill();\n            this.frameContext.strokeStyle = 'white';\n            this.frameContext.lineWidth = 2;\n            this.frameContext.stroke();\n        });\n    }\n    \n    async confirmPoints() {\n        if (this.selectedPoints.length === 0) return;\n        \n        try {\n            const points = this.selectedPoints.map(p => [p.x, p.y]);\n            const labels = this.selectedPoints.map(p => p.type === 'positive' ? 1 : 0);\n            \n            const response = await fetch(`/select_points/${this.sessionId}`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({ points: { coords: points, labels: labels } })\n            });\n            \n            const data = await response.json();\n            \n            if (response.ok) {\n                this.showMessage(data.message, 'success');\n                this.updateTrackingPointsSummary();\n                this.nextStep();\n            } else {\n                throw new Error(data.error || '座標の設定に失敗しました');\n            }\n        } catch (error) {\n            this.showMessage(`エラー: ${error.message}`, 'error');\n        }\n    }\n    \n    updateTrackingPointsSummary() {\n        const container = document.getElementById('tracking-points-summary');\n        \n        const positiveCount = this.selectedPoints.filter(p => p.type === 'positive').length;\n        const negativeCount = this.selectedPoints.filter(p => p.type === 'negative').length;\n        \n        container.innerHTML = `\n            <div class=\"alert alert-info\">\n                <strong>選択済み座標:</strong><br>\n                <i class=\"fas fa-check text-success\"></i> 追跡対象: ${positiveCount}個<br>\n                <i class=\"fas fa-times text-danger\"></i> 除外領域: ${negativeCount}個\n            </div>\n        `;\n    }\n    \n    async startTracking() {\n        if (!this.sessionId) return;\n        \n        const modelSize = document.getElementById('model-size').value;\n        \n        try {\n            const response = await fetch(`/start_tracking/${this.sessionId}`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({ model_size: modelSize })\n            });\n            \n            const data = await response.json();\n            \n            if (response.ok) {\n                this.showMessage(data.message, 'info');\n                this.startStatusCheck();\n            } else {\n                throw new Error(data.error || '追跡開始に失敗しました');\n            }\n        } catch (error) {\n            this.showMessage(`エラー: ${error.message}`, 'error');\n        }\n    }\n    \n    showResults(results) {\n        const container = document.getElementById('results-summary');\n        \n        container.innerHTML = `\n            <div class=\"row\">\n                <div class=\"col-md-3\">\n                    <div class=\"result-stat\">\n                        <h4>${results.total_frames}</h4>\n                        <p>総フレーム数</p>\n                    </div>\n                </div>\n                <div class=\"col-md-3\">\n                    <div class=\"result-stat\">\n                        <h4>${results.processed_frames}</h4>\n                        <p>処理フレーム数</p>\n                    </div>\n                </div>\n                <div class=\"col-md-3\">\n                    <div class=\"result-stat\">\n                        <h4>${results.processing_time}</h4>\n                        <p>処理時間</p>\n                    </div>\n                </div>\n                <div class=\"col-md-3\">\n                    <div class=\"result-stat\">\n                        <h4>${results.model_size}</h4>\n                        <p>使用モデル</p>\n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"mt-3\">\n                <h5>検出統計</h5>\n                <div class=\"alert alert-success\">\n                    ${Object.entries(results.objects_detected)\n                        .map(([id, count]) => `オブジェクト${id}: ${count}フレームで検出`)\n                        .join('<br>')}\n                </div>\n            </div>\n            \n            ${results.demo_mode ? `\n                <div class=\"alert alert-warning\">\n                    <i class=\"fas fa-info-circle me-2\"></i>\n                    <strong>注意:</strong> これはデモ版の結果です。実際のSAM2追跡を実行するには、\n                    sam2ディレクトリ内でCLIアプリケーションを使用してください。\n                </div>\n            ` : ''}\n        `;\n    }\n    \n    downloadResults() {\n        if (!this.sessionId) return;\n        \n        window.location.href = `/download_results/${this.sessionId}`;\n    }\n    \n    newSession() {\n        if (this.sessionId) {\n            fetch(`/cleanup/${this.sessionId}`, { method: 'POST' });\n        }\n        \n        // リセット\n        this.sessionId = null;\n        this.selectedPoints = [];\n        this.currentStep = 1;\n        \n        // UI リセット\n        this.resetUI();\n    }\n    \n    // UI ヘルパーメソッド\n    nextStep() {\n        this.currentStep++;\n        this.updateStepUI();\n    }\n    \n    updateStepUI() {\n        // ステップインジケーター更新\n        for (let i = 1; i <= 5; i++) {\n            const stepEl = document.getElementById(`step-${i}`);\n            stepEl.classList.remove('active', 'completed');\n            \n            if (i < this.currentStep) {\n                stepEl.classList.add('completed');\n            } else if (i === this.currentStep) {\n                stepEl.classList.add('active');\n            }\n        }\n        \n        // セクション表示切り替え\n        const sections = ['upload', 'frames', 'preview', 'tracking', 'results'];\n        sections.forEach((section, index) => {\n            const sectionEl = document.getElementById(`${section}-section`);\n            sectionEl.style.display = index + 1 === this.currentStep ? 'block' : 'none';\n        });\n    }\n    \n    updateProgress(data) {\n        const progressBars = document.querySelectorAll('.progress-bar');\n        const statusSpans = document.querySelectorAll('[id$=\"-status\"]');\n        \n        progressBars.forEach(bar => {\n            bar.style.width = `${data.progress}%`;\n        });\n        \n        statusSpans.forEach(span => {\n            span.textContent = data.message;\n        });\n    }\n    \n    showUploadProgress(show) {\n        const progressEl = document.getElementById('upload-progress');\n        progressEl.style.display = show ? 'block' : 'none';\n    }\n    \n    showMessage(message, type = 'info') {\n        const alertEl = document.getElementById('status-alert');\n        const messageEl = document.getElementById('status-message');\n        \n        alertEl.className = `alert alert-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'info'}`;\n        messageEl.textContent = message;\n        alertEl.style.display = 'block';\n        \n        // 3秒後に自動で非表示\n        setTimeout(() => {\n            alertEl.style.display = 'none';\n        }, 3000);\n    }\n    \n    resetUI() {\n        // フォームリセット\n        document.getElementById('video-file').value = '';\n        \n        // プログレスバーリセット\n        document.querySelectorAll('.progress-bar').forEach(bar => {\n            bar.style.width = '0%';\n        });\n        \n        // ステップリセット\n        this.updateStepUI();\n        \n        // キャンバスクリア\n        if (this.frameContext) {\n            this.frameContext.clearRect(0, 0, this.frameCanvas.width, this.frameCanvas.height);\n        }\n        \n        // 座標リストクリア\n        this.clearPoints();\n        \n        // アラート非表示\n        document.getElementById('status-alert').style.display = 'none';\n    }\n}\n\n// アプリケーション初期化\nlet app;\ndocument.addEventListener('DOMContentLoaded', () => {\n    app = new SAM2WebApp();\n});